<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="addons/sc-text-node.html">
<link rel="import" href="../styles/sc-text-styles.html">
<link rel="import" href="../styles/sc-text-heading-styles.html">
<link rel="import" href="../styles/sc-text-paragraph-num-styles.html">

<dom-module id="sc-page-text" attributes="suttatitle suttameta">
<template>
<style is="custom-style" include="sc-text-styles sc-text-heading-styles sc-text-paragraph-num-styles">
.notfound {
  @apply --paper-font-display1;
}
</style>
<!-- Still to do: add the correct sutta based on the author. Right now it does not check the author in the URL -->
<iron-ajax id="ajax"
      url="[[_computeURL(suttaPath,author)]]"
      handle-as="text"
      last-response="{{suttaText}}"
      last-error='{{notFound}}'></iron-ajax>

<iron-ajax
      auto
      url="../data/paragraphtitles.json"
      handle-as="json"
      last-response="{{paragraphTitles}}"></iron-ajax>

    <template is="dom-if" if="[[notFound]]">
        <p class="notfound">Sorry, the page your requested does not exist.</p>
    </template>
    <template is="dom-if" if="[[!notFound]]">
      <sc-text-node category="[[suttaPath]]" input-language="[[inputLanguage]]"></sc-text-node>
      <div id="htmltextcontent" inner-h-t-m-l="[[suttaText]]"></div>
    </template>
</template>
<script>
    Polymer({
      is: 'sc-page-text',

      properties: {
        suttaPath: {
          type: String,
          notify: true,
          observer: '_callAjax'
        },
        author: {
          type: String,
          notify: true,
          observer: '_callAjax'
        },
        suttaText: {
          type: String,
          notify: true,
          value: function(){return ""}
        },
        paragraphTitles: {
            type: Object,
            notify: true,
            value: function(){return {}}
        },
        inputLanguage: String,
        notFound: Object,
        showParagraphs: {
          type: Boolean,
          notify: true,
          observer: '_addParagraphs'
        }
      },
      observers: [
        '_computePars(suttaText,paragraphTitles)',
        'infoToParent(suttaText)'
      ],
      _callAjax: function() {
        if (this.suttaPath) {var matches = this.suttaPath.match(/\d{1,6}/)};
        return (matches && this.author && this.author !== "sujato") ? this.$.ajax.generateRequest() : "";
      },
      _computeURL: function(category,author) {
        return `../texts/${category}.html`;
      },
      _addParagraphs: function(showParagraphs) {
        var infotext = this.shadowRoot.querySelector('#htmltextcontent');
        return (infotext && !showParagraphs) ? infotext.classList.remove('infomode') : (infotext) ? infotext.classList.add('infomode') : "";
      },
      _computeTitle: function(suttaText) {
        var matches = suttaText.match(/class="division">(.*?)</);
        return matches ? matches[1] : "";
      },
      _computeAuthor: function(suttaText) {
        var matches = suttaText.match(/author="(.*?)"/);
        return matches ? matches[1] : "";
      },
      _computeMeta: function(suttaText) {
        var matches = suttaText.match(/<aside id="metaarea">((.|\n)*)<\/aside>/);
        return matches ? matches[1] : "";
      },
     _computePars: function(inputText,paragraphTitles) {
        for (var key in paragraphTitles) {
                var refs = this.shadowRoot.querySelectorAll('.'+key);
                Array.from(refs).forEach(item => item.innerHTML = item.id.replace(key,""));
                Array.from(refs).forEach(item => item.title = paragraphTitles[key]);
        }
      },
      infoToParent: function(suttaText) {
        this.fire('eventFromTextPage',{suttatitle:this._computeTitle(suttaText)+"â€”"+this._computeAuthor(suttaText),suttameta:this._computeMeta(suttaText)});
      }
    });
</script>
</dom-module>

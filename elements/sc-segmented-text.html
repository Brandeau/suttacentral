<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="addons/sc-segment.html">

<link rel="import" href="addons/sc-tooltip.html">

<dom-module id="sc-segmented-text" attributes="suttasegtitle suttasegmeta">
<template>
<style is="custom-style">
.textcontent {
  @apply(--sc-paper-font-body);
  @apply(--sc-serif-font);
  color: var(--primary-text-color);
  margin: 0 auto 4em!important;
  padding: 0 5%!important;
  max-width: 640px;
  display: block;
}
.textcontent.expanded {
  max-width: 60em;
}
.lineblock >div {
  vertical-align: top;
}
.linepi {
  @apply(--sc-sans-font);
}

.sidebyside >div {
  display: inline-block;
  width: 48%;
  padding: 0 5px;
}
.hidepali {
    display:none;
}

</style>
<iron-ajax id="ajaxbase"
      url="[[_computeURLBase(suttaPath)]]"
      handle-as="json"
      last-response="{{baseText}}"></iron-ajax>

  <div class="textcontent">
      <div class="hgroup" inner-h-t-m-l="<p class='division'>{{suttaText.division}}</p><h1>{{suttaText.title}}</h1>"></div>
      <template is="dom-repeat" items="{{baseText}}" as="line">
        <div class="lineblock">
            <div class="line" inner-h-t-m-l="{{line}}"></div>
            <div class="linepi hidepali" inner-h-t-m-l="{{line}}"></div>
        </div>
      </template>
  </div>

<iron-ajax id="ajaxalternate"
              url="[[_computeURLOriginal(suttaPath)]]"
              handle-as="json"
              last-response="{{alternateText}}"></iron-ajax>

<iron-ajax id="ajaxsutta"
      url="[[_computeURL(suttaPath)]]"
      handle-as="json"
      last-response="{{suttaText}}"></iron-ajax>

<iron-ajax id="ajaxparagraphs"
      url="../data/paragraphtitles.json"
      handle-as="json"
      last-response="{{paragraphTitles}}"></iron-ajax>

</template>
<script>
    Polymer({
        is: 'sc-segmented-text',
      properties: {
        suttaPath: {
          type: String,
          notify: true,
          observer: '_callAjax'
        },
        author: {
          type: String,
          notify: true,
          observer: '_callAjax'
        },
        suttaText: Object,
        alternateText: Object,
        paragraphTitles: {
          type: Object,
          notify: true
        },
        showViewer: {
          type: String
        },
        hidePali: {
          type: String,
          value: "hidepali"
        }
      },
      observers: [
       'setView(showViewer)',
       ' _computeSegments(suttaText,".line")',
       ' _computeSegments(alternateText,".linepi")'
      ],
      _callAjax: function(){
        if (this.suttaPath) {var matches = this.suttaPath.match(/\d{1,6}/)};
        if (matches && this.author && this.author === "sujato") {
            this.$.ajaxparagraphs.generateRequest();
            this.$.ajaxbase.generateRequest();
            this.$.ajaxalternate.generateRequest();
            this.$.ajaxsutta.generateRequest();
        }
      },
       setView: function(showViewer) {
        this._cleanCode();
        switch (showViewer) {
          case "sidebyside":
              this.$$('.textcontent').classList.add('expanded');
              Array.from(this.querySelectorAll('.linepi')).forEach(item => item.classList.remove('hidepali'));
              Array.from(this.querySelectorAll(".lineblock")).forEach(item => item.classList.add('sidebyside'));
              break;
          case "linebyline":
              Array.from(this.querySelectorAll('.linepi')).forEach(item => item.classList.remove('hidepali'));
              break;
          case "popup":
              Array.from(this.querySelectorAll(".line sc-segment")).forEach(item => item.innerHTML = "<sc-tooltip fit-to-visible-bounds='.line'>" + this.alternateText.segments[item.id] + "</sc-tooltip>" + item.innerHTML);
              break;
        }
      },
      _computeURL: function(category) {
        return `../texts/sujato/${category}.json`;
      },
      _computeURLBase: function(category) {
        return `../texts/${category}.json`;
      },
      _computeURLOriginal: function(category) {
        return `../texts/pi/${category}.json`;
      },
     _computePars: function() {
        for (var key in this.paragraphTitles) {
                var refs = this.querySelectorAll('.'+key);
                Array.from(refs).forEach(item => item.innerHTML = item.id.replace(key,""));
                Array.from(refs).forEach(item => item.title = this.paragraphTitles[key]);
          }
      },
      _computeSegments: function(inputText,linetype) {
        if (inputText) {
          Array.from(this.querySelectorAll(linetype+" sc-segment")).forEach(item => item.innerHTML = inputText.segments[item.id]);
          this._computePars();
        }
        if (this.suttaText) {this.infoToParent();}
      },
      _cleanCode: function() {
          Array.from(this.querySelectorAll(".line sc-tooltip")).forEach(item => item.innerHTML = item.innerHTML.replace("<sc-tooltip/([^]*)/</sc-tooltip>",""));
          Array.from(this.querySelectorAll(".sidebyside")).forEach(item => item.classList.remove('sidebyside'));
          this.$$('.textcontent').classList.remove('expanded');
          Array.from(this.querySelectorAll('.linepi')).forEach(item => item.classList.add('hidepali'));
      },
      infoToParent: function() {
        if(this.showViewer != undefined){this.setView(this.showViewer);};
        this.fire('eventFromSegmentedTextPage',{suttasegtitle:this.suttaText.division+"â€”"+this.suttaText.author,suttasegmeta:this.suttaText.meta});
      }
    });
</script>
</dom-module>
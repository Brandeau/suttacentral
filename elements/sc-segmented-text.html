<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="addons/sc-text-node.html">
<link rel="import" href="../styles/sc-text-styles.html">
<link rel="import" href="../styles/sc-text-heading-styles.html">
<link rel="import" href="../styles/sc-text-paragraph-num-styles.html">
<link rel="import" href="../bower_components/paper-tooltip/paper-tooltip.html">

<dom-module id="sc-segmented-text" attributes="suttasegtitle suttasegmeta">
<template>
<style is="custom-style" include="sc-text-styles sc-text-heading-styles sc-text-paragraph-num-styles">
.notfound {
  @apply --paper-font-display1;
}
.original-text {
  @apply --sc-sans-font;
}
.sidebyside {
  display: inline-block;
  width: 47%;
  padding: 0 5px;
  vertical-align: text-top;
}

.hidepali {
    display:none;
}
.linebyline {
  display: block;
}
paper-tooltip {
  --paper-tooltip-opacity: 0.98;
  --paper-tooltip-background: var(--paper-grey-700);
  --paper-tooltip: {
        @apply --sc-sans-font;
        @apply --shadow-elevation-6dp;
        font-size: 12px;
        line-height: 16px;
        padding: 8px 16px;
        text-shadow:0px 0px #ffffff;
        white-space: normal;
  };
}
</style>
<iron-ajax id="ajax"
      url="[[_computeURL(suttaPath,author)]]"
      handle-as="text"
      last-response="{{suttaText}}"
      last-error='{{notFound}}'
      on-response="_loadedHTML"></iron-ajax>

<iron-ajax id="ajaxParagraphs"
      url="../data/paragraphtitles.json"
      handle-as="json"
      last-response="{{paragraphTitles}}"
      on-response="_computePars"></iron-ajax>

    <template is="dom-if" if="[[notFound]]">
        <p class="notfound">Sorry, the page your requested does not exist.</p>
    </template>
    <template is="dom-if" if="[[!notFound]]">
      <sc-text-node category="[[suttaPath]]" input-language="[[inputLanguage]]"></sc-text-node>
      <div id="htmltextcontent" inner-h-t-m-l="[[suttaText]]"></div>
    </template>

<iron-ajax id="ajaxTranslated"
      url="[[_computeTranslatedURL(suttaPath,author)]]"
      handle-as="json"
      last-response="{{suttaTranslatedText}}"
      on-response="_addTranslatedText"></iron-ajax>

<iron-ajax id="ajaxOriginal"
      url="[[_computeOriginalURL(suttaPath,author)]]"
      handle-as="json"
      last-response="{{suttaOriginalText}}"
      on-response="_addOriginalText"></iron-ajax>

</template>
<script>
    Polymer({
      is: 'sc-segmented-text',

      properties: {
        suttaPath: {
          type: String,
          notify: true
        },
        author: {
          type: String,
          notify: true
        },
        suttaText: {
          type: String,
          notify: true,
          value: function(){return ""}
        },
        suttaTranslatedText: {
          type: Object,
          notify: true,
          value: function(){return {}}
        },
        suttaOriginalText: {
          type: Object,
          notify: true,
          value: function(){return {}}
        },
        inputLanguage: String,
        notFound: Object,
        showParagraphs: {
          type: Boolean,
          notify: true,
          observer: '_addParagraphs'
        },
        htmlLoaded: {
          type: Boolean,
          notify: true
        },
        showViewer: {
          type: String,
          observer: 'setView'
        },
      },
      observers: [
        'infoToParent(suttaTranslatedText)',
        '_callAjax(suttaPath,author)',
      ],
      _callAjax: function() {
        this.htmlLoaded = false;
        if (this.suttaPath) {var matches = this.suttaPath.match(/\d{1,6}/)};
        if (matches && this.author && this.author === "sujato") {
         this.$.ajax.generateRequest();
       }
      },
      _computeURL: function(category,author) {
        if (category.startsWith("dn") || category.startsWith("mn")) {
                var pathname = category.replace(/\d{1,5}/,"");
                return `../data/texts/markup/${pathname}/${category}.html`;
        } else if (category.startsWith("an") || category.startsWith("sn")) {
          // Polymer problem here with loading anything with a dot in the path. Bug report filed.
                var pathname = category.replace(/[\d{1,5}\-\.]/g,"");
                console.log(pathname);
                var subpathname = category.split(".",1)[0];
                console.log(subpathname);
                category.replace(/\./,"\\\.");
                return `../data/texts/markup/${pathname}/${subpathname}/${category}.html`;
        }
      },
      _computeTranslatedURL: function(category,author) {
        if (category.startsWith("dn") || category.startsWith("mn")) {
            var pathname = category.replace(/\d{1,5}/,"");
            return `../data/texts/en/sujato/${pathname}/${category}.json`;
        } else if (category.startsWith("an") || category.startsWith("sn")) {
          // Polymer problem here with loading anything with a dot in the path. Bug report filed.
                var pathname = category.replace(/[\d{1,5}\-\.]/g,"");
                console.log(pathname);
                var subpathname = category.split(".",1)[0];
                console.log(subpathname);
                return `../data/texts/en/sujato/${pathname}/${subpathname}/${category}.html`;
        }
      },
      _computeOriginalURL: function(category,author) {
        if (category.startsWith("dn") || category.startsWith("mn")) {
            var pathname = category.replace(/\d{1,5}/,"");
            return `../data/texts/pi/${pathname}/${category}.json`;
        } else if (category.startsWith("an") || category.startsWith("sn")) {
          // Polymer problem here with loading anything with a dot in the path. Bug report filed.
                var pathname = category.replace(/[\d{1,5}\-\.]/g,"");
                console.log(pathname);
                var subpathname = category.split(".",1)[0];
                console.log(subpathname);
                return `../data/texts/pi/${pathname}/${subpathname}/${category}.html`;
        }
      },
      _loadedHTML: function(e) {
        this.$.ajaxTranslated.generateRequest();
        this.$.ajaxOriginal.generateRequest();
        this.$.ajaxParagraphs.generateRequest();
      },
      _addTranslatedText: function(e) {
        outputText = e.detail.response;
        for (var key in outputText) {
          if (!key.startsWith("_")) {
                subkey = key.replace(/:/,"\\\:");
                subkey = subkey.replace(/\./,"\\\.");
                var segment = this.shadowRoot.querySelector('#'+subkey);
                segment.innerHTML = outputText[key]+" ";
                segment.classList.add("translated-text");
          }
        }
      },
      _addOriginalText: function(e) {
        outputText = e.detail.response;
        for (var key in outputText) {
          if (!key.startsWith("_")) {
                subkey = key.replace(/:/,"\\\:");
                subkey = subkey.replace(/\./,"\\\.");
                var segment = this.shadowRoot.querySelector('#'+subkey);
                var newSegment = document.createElement('sc-segment');
                newSegment.id = "pi"+key;
                newSegment.classList.add("original-text");
                newSegment.classList.add("hidepali");
                newSegment.innerHTML = outputText[key]+" ";
                segment.parentNode.insertBefore(newSegment, segment.nextSibling);
          }
        }
        this.htmlLoaded = true;
        if (this.showViewer) {this.setView(this.showViewer)};
      },
      _addParagraphs: function() {
        var infotext = this.shadowRoot.querySelector('#htmltextcontent');
        return (infotext && !this.showParagraphs) ? infotext.classList.remove('infomode') : (infotext) ? infotext.classList.add('infomode') : "";
      },
      _computeTitle: function(suttaText) {
        return suttaText[this.suttaPath+":1.1"];
      },
      _computeAuthor: function(suttaTranslatedText) {
        return "Bhikkhu Sujato";
      },
      _computeMeta: function(suttaText) {
        return "There is no Meta Area defined for Bhante Sujato's texts yet.";
      },
     _computePars: function(e) {
      var paragraphTitles = e.detail.response;
        for (var key in paragraphTitles) {
                var refs = this.shadowRoot.querySelectorAll('.'+key);
                Array.from(refs).forEach(item => item.innerHTML = item.id.replace(key,""));
                Array.from(refs).forEach(item => item.title = paragraphTitles[key]);
        }
        if (this.showParagraphs) {this._addParagraphs()};
      },
      infoToParent: function(suttaTranslatedText) {
        this.fire('eventFromSegmentedTextPage',{suttasegtitle:this._computeTitle(suttaTranslatedText)+"â€”"+this._computeAuthor(suttaTranslatedText),suttasegmeta:this._computeMeta(suttaTranslatedText)});
      },
      setView: function(textinput) {
        if (this.htmlLoaded) {
                this._cleanCode();
                switch (this.showViewer) {
                  case "sidebyside":
                      this.$$('section').classList.add('expand-area');
                      Array.from(this.shadowRoot.querySelectorAll('.original-text')).forEach(item => item.classList.remove('hidepali'));
                      Array.from(this.shadowRoot.querySelectorAll("sc-segment")).forEach(item => item.classList.add('sidebyside'));
                      break;
                  case "linebyline":
                      Array.from(this.shadowRoot.querySelectorAll('.original-text')).forEach(item => item.classList.remove('hidepali'));
                      Array.from(this.shadowRoot.querySelectorAll("sc-segment")).forEach(item => item.classList.add('linebyline'));
                      break;
                  case "popup":
                      Array.from(this.shadowRoot.querySelectorAll(".translated-text")).forEach(item => item.innerHTML = "<paper-tooltip fit-to-visible-bounds>" + this.suttaOriginalText[item.id] + "</paper-tooltip>" + item.innerHTML);
                      break;
                    }
                  }
        },
        _cleanCode: function() {
              this.$$('section').classList.remove('expand-area');
              Array.from(this.shadowRoot.querySelectorAll('.original-text')).forEach(item => item.classList.add('hidepali'));
              Array.from(this.shadowRoot.querySelectorAll("sc-segment")).forEach(item => item.classList.remove('sidebyside'));
              Array.from(this.shadowRoot.querySelectorAll("sc-segment")).forEach(item => item.classList.remove('linebyline'));
              Array.from(this.shadowRoot.querySelectorAll("paper-tooltip")).forEach(item => item.parentNode.removeChild(item));
        }
    });
</script>
</dom-module>

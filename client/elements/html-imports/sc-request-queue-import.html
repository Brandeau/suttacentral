<script>
    'use strict';
    const defaultOptions =
        {
            defaultPorts: { ftp: 21, http: 80, https: 443 },
            ignorePorts: true,
            ignoreSchemes: true,
            ignoreSubdomains: true,
            maxSockets: Infinity,
            maxSocketsPerHost: 1,
            rateLimit: 0
        };

    function getHostKey(url, options) {
        let key, port, protocol, urlDomain;

        if (url == null) {
            return false;
        }
        else if (isString(url) === true) {
            try {
                url = new URL(url);
            }
            catch (error) {
                return false;
            }
        }

        protocol = url.protocol;

        if (isEmptyString(protocol) === true || isEmptyString(url.hostname) === true) {
            return false;
        }

        if (protocol.indexOf(':') === protocol.length - 1) {
            protocol = protocol.substr(0, protocol.length - 1);
        }

        port = url.port;

        // TODO :: remove support for node-js url.parse objects
        if (isEmptyStringOrNumber(port) === true && options.defaultPorts[protocol] !== undefined) {
            port = options.defaultPorts[protocol];
        }

        key = '';

        if (options.ignoreSchemes === false) {
            key += protocol + '://';
        }

        key += url.hostname;

        if (options.ignorePorts === false && port != null) {
            key += ':' + port;
        }

        key += '/';

        return key;
    }


    function isEmptyString(value) {
        return value === '' || value == null || isString(value) === false;
    }


    function isEmptyStringOrNumber(value) {
        return value === '' || value == null || isNaN(value) === true;
    }

    const strValue = String.prototype.valueOf;
    const tryStringObject = function tryStringObject(value) {
        try {
            strValue.call(value);
            return true;
        } catch (e) {
            return false;
        }
    };
    const toStr = Object.prototype.toString;
    const strClass = '[object String]';
    const hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

    function isString(value) {
        if (typeof value === 'string') {
            return true;
        }
        if (typeof value !== 'object') {
            return false;
        }
        return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
    }

    function RequestQueue(options, handlers) {
        this.activeHosts = {};    // Socket counts stored by host
        this.items = {};          // Items stored by ID
        this.priorityQueue = [];  // List of IDs

        this.activeSockets = 0;
        this.counter = 0;
        this.handlers = handlers || {};
        this.options = Object.assign({}, defaultOptions, options);
        this.paused = false;
    }

    RequestQueue.prototype.dequeue = function(id) {
        const item = this.items[id];

        if (item === undefined || item.active === true) {
            return new Error('ID not found');
        }

        dequeue(item, this);
        remove(item, this);

        return true;
    };

    RequestQueue.prototype.enqueue = function(input) {
        let idOrError;

        if (input == null || isString(input) === true) {
            input = { url: input };
        }

        idOrError = enqueue(input, this);

        if (idOrError instanceof Error === false) {
            startNext(this);
        }

        return idOrError;
    };

    RequestQueue.prototype.length = function() {
        return this.priorityQueue.length + this.activeSockets;
    };

    RequestQueue.prototype.numActive = function() {
        return this.activeSockets;
    };

    RequestQueue.prototype.numQueued = function() {
        return this.priorityQueue.length;
    };

    RequestQueue.prototype.pause = function() {
        this.paused = true;
    };

    RequestQueue.prototype.resume = function() {
        this.paused = false;

        startNext(this);
    };

    //::: PRIVATE FUNCTIONS


    /*
      Call a class' event handler if it exists.
    */
    function callHandler(handler, args, timeout) {
        if (typeof handler === 'function') {
            if (timeout > 0) {
                setTimeout(function() {
                    handler.apply(null, args);

                }, timeout);
            }
            else {
                handler.apply(null, args);
            }
        }
    }


    /*
      Remove item (id) from queue, but nowhere else.
    */
    function dequeue(item, instance) {
        const queueIndex = instance.priorityQueue.indexOf(item.id);

        if (queueIndex < 0) return false;

        instance.priorityQueue.splice(queueIndex, 1);

        return true;
    }


    /*
      Add item to queue and item list.
    */
    function enqueue(input, instance) {
        const hostKey = getHostKey(input.url, instance.options);
        let id = input.id;

        if (hostKey === false) {
            return new TypeError('Invalid URL');
        }

        if (id == null) id = instance.counter++;

        if (instance.items[id] !== undefined) {
            return new Error('Non-unique ID');
        }

        instance.items[id] = { active: false, hostKey: hostKey, id: id, input: input };
        instance.priorityQueue.push(id);

        return id;
    }


    /*
      Generate a `done()` function for use in resuming the queue when an item's
      process has been completed.
    */
    function getDoneCallback(item, instance) {
        return function() {
            instance.activeSockets--;

            remove(item, instance);

            startNext(instance);
        };
    }


    /*
      Remove item from item list and activeHosts.
    */
    function remove(item, instance) {
        instance.activeHosts[item.hostKey]--;

        if (instance.activeHosts[item.hostKey] <= 0) {
            delete instance.activeHosts[item.hostKey];
        }

        delete instance.items[item.id];

        if (instance.priorityQueue.length <= 0 && instance.activeSockets <= 0) {
            instance.counter = 0;  // reset

            callHandler(instance.handlers.end, []);
        }
    }


    /*
      Possibly start next request(s).
    */
    function startNext(instance) {
        let availableSockets = instance.options.maxSockets - instance.activeSockets;
        let i = 0;
        let canStart, currItem;

        if (instance.paused === true) return;
        if (availableSockets <= 0) return;

        while (i < instance.priorityQueue.length) {
            canStart = false;
            currItem = instance.items[instance.priorityQueue[i]];

            // Not important, but feature complete
            if (instance.options.maxSocketsPerHost > 0) {
                if (instance.activeHosts[currItem.hostKey] === undefined) {
                    // Create key with first count
                    instance.activeHosts[currItem.hostKey] = 1;
                    canStart = true;
                }
                else if (instance.activeHosts[currItem.hostKey] < instance.options.maxSocketsPerHost) {
                    instance.activeHosts[currItem.hostKey]++;
                    canStart = true;
                }
            }

            if (canStart === true) {
                instance.activeSockets++;
                availableSockets--;

                currItem.active = true;

                dequeue(currItem, instance);

                callHandler(instance.handlers.item, [currItem.input, getDoneCallback(currItem, instance)], instance.options.rateLimit);

                if (availableSockets <= 0) break;
            }
            else {
                // Move onto next
                i++;
            }
        }
    }
</script>